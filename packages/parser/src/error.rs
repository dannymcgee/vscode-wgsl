use std::fmt;

use crate::Rule;

impl fmt::Display for Rule {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		use Rule::*;

		let text = match self {
			EOI => "end of file",
			COMMENT => "comment",
			WHITESPACE => "whitespace",
			LBRACE => "`{`",
			RBRACE => "`}`",
			LBRACK => "`[`",
			RBRACK => "`]`",
			LDBRACK => "`[[`",
			RDBRACK => "`]]`",
			LPAREN => "`(`",
			RPAREN => "`)`",
			LANGLE => "`<`",
			RANGLE => "`>`",
			AND => "`&`",
			AND_AND => "`&&`",
			ARROW => "`->`",
			BANG => "`!`",
			COLON => "`:`",
			COMMA => "`,`",
			DOT => "`.`",
			EQUAL => "`=`",
			EQUAL_EQUAL => "`==`",
			GT => "`>`",
			GTE => "`>=`",
			LSHIFT => "`<<`",
			LT => "`<`",
			LTE => "`<=`",
			MINUS => "`-`",
			MINUS_MINUS => "`--`",
			MODULO => "`%`",
			NOT_EQUAL => "`!=`",
			OR => "`|`",
			OR_OR => "`||`",
			PLUS => "`+`",
			PLUS_PLUS => "`++`",
			RSHIFT => "`>>`",
			SEMICOLON => "`;`",
			SLASH => "`/`",
			STAR => "`*`",
			TILDE => "`~`",
			XOR => "`^`",
			ARRAY => "`array`",
			ATOMIC => "`atomic`",
			BOOL => "`bool`",
			FLOAT32 => "`f32`",
			INT32 => "`i32`",
			UINT32 => "`u32`",
			MATRIX => "matrix type",
			PTR => "`ptr`",
			SAMPLER => "sampler type",
			VEC => "vector type",
			MULTISAMPLED_TEXTURE_TYPE => "texture type",
			EXTERN_TEXTURE_TYPE => "texture type",
			DEPTH_TEXTURE_TYPE => "texture type",
			SAMPLER_TYPE => "sampler type",
			SAMPLED_TEXTURE_TYPE => "sampled texture type",
			STORAGE_TEXTURE_TYPE => "storage texture type",
			FN => "`fn`",
			LET => "`let`",
			STRUCT => "`struct`",
			TYPE => "`type`",
			VAR => "`var`",
			FUNCTION => "`function`",
			PRIVATE => "`private`",
			READ => "`read`",
			READ_WRITE => "`read_write`",
			STORAGE => "`storage`",
			UNIFORM => "`uniform`",
			WORKGROUP => "`workgroup`",
			WRITE => "`write`",
			BREAK => "`break`",
			CASE => "`case`",
			CONTINUE => "`continue`",
			CONTINUING => "`continuing`",
			DEFAULT => "`default`",
			ELSE => "`else`",
			ELSE_IF => "`elseif`",
			FALLTHROUGH => "`fallthrough`",
			FOR => "`for`",
			IF => "`if`",
			LOOP => "`loop`",
			RETURN => "`return`",
			SWITCH => "`switch`",
			FALSE => "`false`",
			TRUE => "`true`",
			BITCAST => "`bitcast`",
			DISCARD => "`discard`",
			ENABLE => "`enable`",
			BLOCK => "`block`",
			SIGN => "`+` or `-`",
			DECIMAL_FLOAT_LITERAL => "float literal",
			HEX_FLOAT_LITERAL => "float literal",
			INT_LITERAL => "int literal",
			UINT_LITERAL => "unsigned int literal",
			FLOAT_LITERAL => "float literal",
			const_literal => "const literal",
			IDENT => "identifier",
			attribute => "attribute",
			attribute_list => "attribute list",
			literal_or_ident => "literal or identifier",
			builtin_type_decl => "type declaration",
			type_decl => "type declaration",
			access_mode => "access mode",
			storage_class => "storage class",
			texel_format => "texel format",
			texture_sampler_type => "texture sampler type",
			struct_decl => "struct declaration",
			struct_body_decl => "struct body",
			struct_member => "struct member",
			type_alias => "type alias",
			variable_stmt => "variable statement",
			variable_decl => "variable declaration",
			variable_ident_decl => "<identifier>: <attributes>? <type declaration>",
			variable_qualifier => "variable qualifier",
			global_const_initializer => "global const initializer",
			global_variable_decl => "global variable declaration",
			global_constant_decl => "global const declaration",
			const_expr => "const expression",
			BINOP => "binary operator",
			expression => "expression",
			singular_expr => "expression",
			unary_expr => "unary expression",
			primary_expr => "primary expression",
			postfix_expr => "postfix expression",
			argument_expr_list => "argument expression list",
			paren_expr => "parenthesized expression",
			func_call_expr => "function call expression",
			statement => "statement",
			compound_stmt => "statements",
			assignment_stmt => "assignment statement",
			if_stmt => "if statement",
			elseif_stmt => "elseif statement",
			else_stmt => "else statement",
			switch_stmt => "switch statement",
			switch_body => "switch body",
			case_stmt => "case statement",
			case_selectors => "case selectors",
			case_body => "case body",
			loop_stmt => "loop statement",
			continuing_stmt => "continuing statement",
			for_stmt => "for statement",
			for_header => "for header",
			return_stmt => "return statement",
			func_call_stmt => "function call statement",
			func_decl => "function declaration",
			func_header => "function header",
			func_return_type => "function return type",
			param_list => "parameter list",
			param => "parameter",
			program => "program",
		};

		write!(f, "{}", text)
	}
}
